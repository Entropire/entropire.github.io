    
      <div class="Header">
        <h1>SimpleCommands</h1>
        <p>A C# library that adds a dynamic command interface to your project.</p>
      </div>
      <div class="ProjectContent">
        <div class="Navigation">
          <ul>
            <li><h4>Table of Contents</h4></li>
            <li><button data-scroll-id="description">Description</button></li>
<li><button data-scroll-id="core-features">Core Features</button></li>
<li><button data-scroll-id="outcome">Outcome</button></li>
<li><button data-scroll-id="command-definition">Command Definition</button></li>
<li><button data-scroll-id="command-storage">Command Storage</button></li>
<li><button data-scroll-id="command-calling">Command Calling</button></li>
<li><button data-scroll-id="reflection">Reflection</button></li>
          </ul>
        </div> 
        <div class="MainContent">
          <div>
              <img src="projects/Img/SimpleCommands/Example.gif" alt="Example GIF" loading="lazy" class="custom-image" />
            </div><h3 id="description">Description</h3><p>I created this project because I found myself rewriting a command interface in multiple c# projects.
So to stop myself from reinventing the wheel and to save time, I decided to build a reusable command system that I could use in all my project where I needed it.
The goal of this project was to create a lightweight, easy-to-use library that provides a flexible way to define, register and trigger commands.
And publish it as a NuGet package for convenient reuse that u can install here//insert link.</p><h3 id="core-features">Core Features</h3><ul>
<li>Define commands with ease</li>
<li>Register and deregister commands dynamically</li>
<li>Switch between command handlers effortlessly</li>
<li>Trigger commands based on user input</li>
</ul>
<h3 id="outcome">Outcome</h3><p>The end result of the project is a library that allows you to define, register, deregister and class commands on rune time.</p><h3 id="command-definition">Command Definition</h3><p>You can create and register a command dynamically either using a class or a lambda expression.</p><p>For example, you can create a command with a dedicated class:</p><pre><code class="language-">[CommandName(<span class="hljs-string">&quot;eco&quot;</span>)]
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EcoCommand</span><span class="hljs-attr"> : Command</span> </span>{ ... }

_handler.RegisterCommand(EcoCommand);</code></pre><p>Or define one inline using a lambda:</p><pre><code class="language-">_handler.RegisterCommand(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-function"><span class="hljs-params">(args, name)</span> =&gt;</span> Console.WriteLine(<span class="hljs-string">&quot;Hello&quot;</span>));</code></pre><h3 id="command-storage">Command Storage</h3><p>Commands are stored in a dictionary for fast lookup and to ensure that no two commands share the same name</p><pre><code class="language-"><span class="hljs-keyword">private</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Action&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>[]&gt;&gt; <span class="hljs-built_in">dictionary</span>OfCommands = new(StringComparer.OrdinalIgnoreCase);</code></pre><h3 id="command-calling">Command Calling</h3><p>Commands can be executed simply by passing a user input string to the handler:</p><pre><code class="language-">string userInput <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/eco helloworld&quot;</span>
_handler.Execute(userInput)<span class="hljs-comment">;</span></code></pre><p>In the background the input string is automatically split into the command name and its arguments,
and the command corresponding to the command name is executed. </p><p>For example, the input ```"/eco helloworld"``` would be parsed into:</p><ul>
<li>Command Name: <code>&quot;eco&quot;</code></li>
<li>Arguments: <code>&quot;[&quot;helloworld&quot;]&quot;</code></li>
</ul>
<p>This makes it easy to handle user input without manually parsing string every time and ensures that the user inputs is always parsed in the same way.</p><h3 id="reflection">Reflection</h3><p>Working on SimpleCommands helped me think carefully about modular and reusable library design.
I learned how to create a flexible API that supports both class-based and inline commands, and how to handle user input consistently with minimal boilerplate.
I also learned how to publish a C# library on NuGet, making it easier to share and reuse across different projects.</p><p>If I were to continue developing this library, Iâ€™d like to add async command support, 
improve error handling and logging, 
and explore ways to extend the command parser for more complex input patterns.</p>        
        </div>
        <div class="ProjectMeta">   
          
                      <div class="Language">
                        <h4>Language</h4>
                        <p value="C#">C#</p>
                      </div>
                    
                      <div class="Year">
                        <h4>Year</h4>
                        <p value="2025">2025</p>
                      </div>
                    
          <div class="Links">
            <h4>Links</h4>
            
                        <a href="https://github.com/Entropire/SimpleCommands" target="_blank" rel="noopener noreferrer">
                          <p>Github</p>
                        </a>
                      
          </div>
        </div>
      </div>
    